"""autogenerated by genmsg_py from JoystickValues.msg. Do not edit."""
import roslib.message
import struct


class JoystickValues(roslib.message.Message):
  _md5sum = "f1af9c9ec7eff6b8ec4f182194e49cb3"
  _type = "joystick_ps3/JoystickValues"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """float64 x_left
float64 y_left
float64 x_right
float64 y_right
bool up
bool down
bool left
bool right
bool triangle
bool x
bool square
bool circle
bool select
bool start
bool playstation
bool L1
bool L2
bool R1
bool R2
"""
  __slots__ = ['x_left','y_left','x_right','y_right','up','down','left','right','triangle','x','square','circle','select','start','playstation','L1','L2','R1','R2']
  _slot_types = ['float64','float64','float64','float64','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       x_left,y_left,x_right,y_right,up,down,left,right,triangle,x,square,circle,select,start,playstation,L1,L2,R1,R2
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(JoystickValues, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.x_left is None:
        self.x_left = 0.
      if self.y_left is None:
        self.y_left = 0.
      if self.x_right is None:
        self.x_right = 0.
      if self.y_right is None:
        self.y_right = 0.
      if self.up is None:
        self.up = False
      if self.down is None:
        self.down = False
      if self.left is None:
        self.left = False
      if self.right is None:
        self.right = False
      if self.triangle is None:
        self.triangle = False
      if self.x is None:
        self.x = False
      if self.square is None:
        self.square = False
      if self.circle is None:
        self.circle = False
      if self.select is None:
        self.select = False
      if self.start is None:
        self.start = False
      if self.playstation is None:
        self.playstation = False
      if self.L1 is None:
        self.L1 = False
      if self.L2 is None:
        self.L2 = False
      if self.R1 is None:
        self.R1 = False
      if self.R2 is None:
        self.R2 = False
    else:
      self.x_left = 0.
      self.y_left = 0.
      self.x_right = 0.
      self.y_right = 0.
      self.up = False
      self.down = False
      self.left = False
      self.right = False
      self.triangle = False
      self.x = False
      self.square = False
      self.circle = False
      self.select = False
      self.start = False
      self.playstation = False
      self.L1 = False
      self.L2 = False
      self.R1 = False
      self.R2 = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      _x = self
      buff.write(_struct_4d15B.pack(_x.x_left, _x.y_left, _x.x_right, _x.y_right, _x.up, _x.down, _x.left, _x.right, _x.triangle, _x.x, _x.square, _x.circle, _x.select, _x.start, _x.playstation, _x.L1, _x.L2, _x.R1, _x.R2))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      end = 0
      _x = self
      start = end
      end += 47
      (_x.x_left, _x.y_left, _x.x_right, _x.y_right, _x.up, _x.down, _x.left, _x.right, _x.triangle, _x.x, _x.square, _x.circle, _x.select, _x.start, _x.playstation, _x.L1, _x.L2, _x.R1, _x.R2,) = _struct_4d15B.unpack(str[start:end])
      self.up = bool(self.up)
      self.down = bool(self.down)
      self.left = bool(self.left)
      self.right = bool(self.right)
      self.triangle = bool(self.triangle)
      self.x = bool(self.x)
      self.square = bool(self.square)
      self.circle = bool(self.circle)
      self.select = bool(self.select)
      self.start = bool(self.start)
      self.playstation = bool(self.playstation)
      self.L1 = bool(self.L1)
      self.L2 = bool(self.L2)
      self.R1 = bool(self.R1)
      self.R2 = bool(self.R2)
      return self
    except struct.error as e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      _x = self
      buff.write(_struct_4d15B.pack(_x.x_left, _x.y_left, _x.x_right, _x.y_right, _x.up, _x.down, _x.left, _x.right, _x.triangle, _x.x, _x.square, _x.circle, _x.select, _x.start, _x.playstation, _x.L1, _x.L2, _x.R1, _x.R2))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 47
      (_x.x_left, _x.y_left, _x.x_right, _x.y_right, _x.up, _x.down, _x.left, _x.right, _x.triangle, _x.x, _x.square, _x.circle, _x.select, _x.start, _x.playstation, _x.L1, _x.L2, _x.R1, _x.R2,) = _struct_4d15B.unpack(str[start:end])
      self.up = bool(self.up)
      self.down = bool(self.down)
      self.left = bool(self.left)
      self.right = bool(self.right)
      self.triangle = bool(self.triangle)
      self.x = bool(self.x)
      self.square = bool(self.square)
      self.circle = bool(self.circle)
      self.select = bool(self.select)
      self.start = bool(self.start)
      self.playstation = bool(self.playstation)
      self.L1 = bool(self.L1)
      self.L2 = bool(self.L2)
      self.R1 = bool(self.R1)
      self.R2 = bool(self.R2)
      return self
    except struct.error as e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
_struct_4d15B = struct.Struct("<4d15B")
